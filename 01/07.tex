\subsection{%
  Лекция \texttt{23.10.13}.%
}

\subheader{Индексы}

Можно попробовать отсортировать записи по какому-нибудь атрибуту и использовать
бинпоиск. Однако запись в БД нельзя прочитать точечно, поэтому приходится читать
блоками, из-за этого бинпоиск не очень эффективен. Также возникают проблемы для
строковых атрибутов (сравнение строк не очень быстрое). Помимо этого не очень
ясно, как поддерживать отсортированность при добавлении/удалении элементов.

\begin{definition}
  \textit{Индекс} --- это структура данных типа ключ-значение,
  где ключ --- это результат некой функции от совокупности атрибутов, 
  а значение~--- адрес хранимой записи.
\end{definition}

Пусть индексом будет первичный ключ, и хранить мы его будем в виде
сбалансированного дерева. Тогда получаем:
\begin{definition}
  \textit{Первичный индекс} --- это индекс, построенный по первичному ключу при условии,
  что исходный файл отсортирован по нему же.
\end{definition}

Первичный индекс является \textit{плотным}, т.е. охватывает все уникальные записи
(количество кортежей в отношении равно количеству вершин в дереве индекса).

\begin{definition}
  \textit{Индекс кластеризации} --- это индекс, построенный по ключевому или
  неключевому полю при условии, что исходный файл отсортирован по нему же.
\end{definition}

\begin{example}
  В качестве индекса кластеризации будем брать первые \(5\) символов ФИО и для
  каждого индекса будем хранить ссылку на первый кортеж в кластере. Теперь по
  ФИО можно быстро найти кластер, где лежат ФИО с одинаковыми первыми \(5\)-ю
  символами, а дальше уже найти требуемый кортеж.
\end{example}

\begin{remark}
  При использовании индекса кластеризации мы ищем баланс между размером и
  плотностью индекса: либо индекс большой и плотный (нужно больше памяти), либо
  индекс маленький и разреженный (нужно меньше памяти).
\end{remark}

\begin{definition}
  \textit{Вторичный индекс} --- это индекс, построенный по неключевому полю при условии,
  что исходный файл не отсортирован.
\end{definition}

\begin{example}
  Почту можно развернуть и кластеризовать.
\end{example}

\begin{remark}
  Дерево индекса не обязательно всегда держать сбалансированным, можно считать
  метрику \quote{разбалансированности} и иногда делать перебалансировку.
\end{remark}

\subheader{Представления}

\begin{definition}
  \textit{Представление} --- это динамически сформированный результат одной 
  или нескольких реляционных операций, сохраненный в виде нового отношения.
\end{definition}

Представления делятся на:
\begin{enumerate}
\item
  Материализованные.

  На самом деле хранятся в памяти и обновляются раз в некоторое время.

\item
  Представления замены.

  В памяти хранится только запрос для получения этого представления. При
  получении запроса извне этот сохраненный запрос подставляется во внешний
  запрос и полученный таким образом запрос выполняется. Такой способ
  обеспечивает безопасность, но не дает выигрыша в скорости (скорее даже снижает
  скорость).
\end{enumerate}

Представления бывают обновляемыми (через них можно что-то поменять в исходных
отношениях) и нет.

\subsubheader{Преимущества}{ представлений}

\begin{enumerate}
\item
  Независимость от данных.

\item
  Повышение защищенности данных.

\item
  Снижение сложности работы с данными.
\end{enumerate}

\subsubheader{Недостатки}{ представлений}

\begin{enumerate}
\item
  Ограниченность в возможностях обновлений.

\item
  Структурные ограничения (вынужденность подстраиваться под заданный интерфейс
  представления).

\item
  Снижение производительности.
\end{enumerate}
