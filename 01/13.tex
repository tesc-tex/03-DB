\subsection{%
  Лекция \texttt{23.11.24}.%
}

\begin{definition}
  Согласованность (consistency)~--- во всех узлах в один момент времени данные
  не противоречат друг другу.
\end{definition}

\begin{definition}
  Доступность (availability)~--- любой запрос к распределенной системе
  завершается корректным откликом в пределах заданного интервала времени, однако
  без гарантии, что ответы всех узлов совпадут.
\end{definition}

\begin{remark}
  В данном случае \textit{корректно} не значит \textit{правильно}. Под
  корректностью подразумевается то, что система не ответит \quote{не знаю}.
\end{remark}

\begin{definition}
  Partition tolerance (на русский переводится примерно как \quote{устойчивость к
  разбиению})~--- расщепление распределенной системы на несколько изолированных
  секций не приводит к некорректности отклика какой-либо из секций.
\end{definition}

\begin{theorem}[CAP-теорема]
  В распределенной системе возможно обеспечить не более двух из трех
  перечисленных свойств: consistency, availability, partition tolerance.
\end{theorem}

\begin{proof}
  Т.к. формальное доказательство CAP-теоремы весьма длинное, то вместо него
  построим конструктивный пример, иллюстрирующий противоречие, заложенное этой
  теоремой. Допустим, мы хотим создать удаленный сервис, в который пользователи
  смогут звонить по телефону. У каждого пользователя будет две опции:
  запланировать событие на некоторую дату и получить список событий,
  запланированных им на текущий день.

  При таком подходе получаем классическую систему, состоящую из одного узла. Ее
  основной проблемой является доступность. В нашем примере может произойти
  следующее:

  \begin{enumerate}
  \item
    Оператор, отвечающий на звонки клиентов, заболел \(\implies\) весь сервис
    теперь не может работать.
  
  \item
    Количество клиентов сильно возросло \(\implies\) один оператор не успевает
    обслуживать их всех. Клиентам приходится подолгу ждать свой очереди.
  \end{enumerate}

  Видя эти проблемы, мы решаем нанять себе несколько помощников. Теперь каждый
  звонок клиента сначала попадает на балансировщик, который определяет какому
  помощнику отправить этого клиента. Сейчас мы не будем вдаваться в то, как
  работает этот балансировщик, лишь предположим самый очевидный вариант: он
  выбирает помощника с наименьшей загруженностью.
  
  Таким образом, мы решили проблему с доступностью: нам лишь нужно нанять
  достаточное количество помощников, чтобы они успевали справляться со всеми
  запросами. Теперь выход из строя одного из помощников не сильно влияет на
  работу всего сервиса, более того, при необходимости можно варьировать
  количество помощников в зависимости от нагрузки на сервис.

  Полученное решение называется распределенной системой с независимыми узлами. У
  него есть очевидная проблема с согласованностью данных: т.к. узлы никак не
  синхронизируются между собой, то пользователь может сначала попасть на один
  узел, оставить там запись о своих запланированных делах, а когда решит узнать
  о том, что он запланировал на сегодня, балансировщик отправит его на другой
  узел. На другом узле нет информации о планах этого пользователя, в итоге мы
  обманываем пользователя.

  Для решения этой проблемы мы решаем делать следующим образом: теперь каждый
  узел при получении запроса на запись, не \quote{кладя трубу} с клиентом,
  отправляет запросы всем остальным узлам, чтобы те зафиксировали у себя новые
  запланированные дела этого клиента.

  Это решение называется распределенной системой с транзакционной синхронизацией
  (с транзакционной репликацией). У этого решения есть проблемы:

  \begin{enumerate}
  \item
    Мы проигрываем в производительности: при каждом запросе на запись необходимо
    отправить данные для синхронизации всем узлам, причем некоторые узлы могут
    быть заняты в это время \(\implies\) нам придется ждать, пока они
    освободятся. В итоге клиенту, который нам позвонил, придется очень долго
    \quote{висеть} на линии, ожидая того, пока все узлы получат необходимые
    данные и \textbf{сообщат исходному узлу об успешном получении}.

  \item
    Если один из узлов вышел из строя, то мы можем неопределенно долго ждать его
    восстановления \(\implies\) теряем доступность данных. Не ждать мы не можем,
    т.к. в таком случае получим неконсистентные данные на разных узлах (когда
    отвалившийся узел вернется в строй).
  \end{enumerate}

  Попытаемся решить вторую проблему. У каждого узла мы сделаем дополнительный
  буфер (\quote{почтовый ящик}). Теперь все данные для синхронизации будут
  приходить в этот буфер, и перед тем, как войти в строй, узел должен будет
  прочитать все \quote{входящие сообщения}, которые другие узлы ему прислали, и
  выполнить необходимые операции для восстановления консистентности данных.

  Полученный подход называется распределенной системой с гарантированной
  репликацией. Его проблема заключается в том, что узлы обычно общаются по сети,
  а в сети могут быть помехи (нельзя гарантировать доставку данных). Таким
  образом, если узел нам не отвечает, то мы не можем гарантированно сказать
  почему это происходит. Проблема может быть как в узле (если он вышел из
  строя), так и в том, что наше соединение с этим узлом не устойчивое и данные
  просто не могут до него дойти. Чтобы решить эту проблему нужно все узлы
  расположить физически близко друг к другу, чтобы можно было передавать данные
  условно напрямую, но тогда нарушается третье свойство (partition
  tolerance)~--- мы не можем разбить такую систему на изолированные части.

  В процессе организации работы нашего вымышленного сервиса мы всегда
  балансировали между согласованностью, доступностью и возможностью разбиения:
  ради чего-то одного приходилось отказываться от другого и никогда не
  получалось собрать все три свойства одновременно.
\end{proof}

Для распределенной системы наиболее важно третье свойство (возможность разбиения
на части), поэтому все распределенные системы это CP или AP системы. CA система
не может быть распределенной.

Виды NoSQL баз данных:

\begin{enumerate}
\item
  Базы данных вида ключ-значение (обычно AP)

\item
  Документоориентированные базы данных (обычно CP)

\item
  Колоночные хранилища (обычно CA)

  Храним набор пар вида \(\langle \text{первичный ключ, значение колонки}
  \rangle\). Данные храним колонками, т.е. сначала идут данные из первой
  колонки, потом из второй и так далее. Из плюсов: можно не хранить
  \texttt{NULL} значения, т.к. если для данного первичного ключа у нас нет пары
  текущего атрибута, то мы можем просто никак это не хранить.

\item
  Графовые базы данных

  О них речь пойдет на следующей лекции.
\end{enumerate}
