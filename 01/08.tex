\subsection{%
  Лекция \texttt{23.10.20}.%
}

\subheader{Надежность}

Данные должны быть целостны и доступны на всем протяжении эксплуатации системы.
Существует физическая и логическая сохранность данных. Проблему физической
сохранности данных можно решить на уровне оборудования. Например, есть RAID
массивы. Самый простой RAID массив (RAID-1, mirror, зеркало) представляет собой
два диска, один из которых содержит копию данных. Такой подход не очень
эффективен, т.к. сильно возрастают затраты на память, а также могут проблемы с
синхронной записью данных сразу на два диска.

Есть RAID-5: этот массив представляет собой три диска, причем на двух
дисках лежат данные, а на третьем~--- побитовый XOR этих данных. В таком случае
требуется меньше дополнительной памяти. Также можно для хранения XOR-a
использовать не один диск, а каждый из трех дисков по-очереди. Например, разбить
данные на блоки, после чего положить первые два блока на первые два диска, а их
XOR~--- на третий. Третий и четвертый блоки можно положить на второй и третий
диски, а их XOR~--- на первый. И так далее по кругу. Таким образом проблему
физического хранения данных можно решить увеличив затраты на оборудование.

\begin{definition}
  \textit{Транзакция} --- это последовательность действий с базой данных, 
  в которой либо все действия выполняются успешно, либо не выполняется ни одно из них.

  Результатом транзакции может быть либо \texttt{commit}, либо
  \texttt{rollback}.
\end{definition}

Свойства транзакции:

\begin{enumerate}
\item[A]
  \textit{Атомарность} (неделимость). 
  В транзакции выполняются либо все действия, либо ни одного.

\item[C]
  \textit{Согласованность}.
  Транзакция переводит одно согласованное состояние в другое
  согласованное состояние без обязательной поддержки согласованности в
  промежуточных точках.

\item[I]
  \textit{Изоляция}. Если запущено несколько конкурирующих транзакций, то любое
  обновление состояния базы данных, выполненное одной транзакцией скрыто от
  других транзакций до ее завершения.

\item[D]
  \textit{Долговечность}. Когда транзакция завершена, ее результат обновления
  сохраняется, даже если в следующий момент произойдет сбой.
\end{enumerate}

4 проблемы конкурирующих транзакций:
\begin{enumerate}
\item
  Проблема потерянного обновления. Несколько транзакций меняют один и тот же
  кортеж. В результате сохраняется результат внесения изменений только последний
  транзакции.

  Пример: у человека \(n\) на счету \(200\) тугриков. Он переводит человеку
  \(k\) \(100\) тугриков. В это же время человек \(m\) переводит человеку \(n\)
  \(100\) тугриков. Две транзакции пытаются изменить счет человека \(n\), в
  итоге у него окажется либо \(100\), либо \(300\) тугриков (в зависимости от
  порядка завершения транзакций).

\item
  Проблема грязного чтения. Возникает при чтении одной транзакцией кортежа,
  которых уже изменен, но еще не сохранен другой незавершенной транзакцией,
  которая потом будет отменена.

  Пример: у человека \(n\) на счету \(200\) тугриков. Он переводит человеку
  \(k\) \(100\) тугриков. В это же время по всей таблице идет транзакция,
  которая считает количество денег на счету и начисляет проценты. Она считает,
  что у \(n\) осталось \(100\) тугриков, однако при этом может возникнуть сбой,
  перевод тугриков не пройдет и \(100\) тугриков вернутся на счет \(n\). В
  результате ему будут начислены неправильные проценты.

\item
  Проблема неповторяемого чтения. При повторном чтении данных, уже считанных
  ранее, транзакция обнаруживает модификации, вызванные другой завершенной
  транзакцией.

  Пример: транзакция идет по таблице и считает сумму покупки, чтобы потом
  вычислить скидку. В это время другая транзакция меняет цены уже прочитанного
  товара. В итоге скидка может быть посчитана неверно.

\item
  Проблема фантомного чтения. При повторном чтении данных транзакция
  обнаруживает новые кортежи, добавленные другой транзакцией, завершенной после
  предыдущего чтения данных.

  Пример: транзакция идет по таблице и считает сумму покупки, чтобы определить
  цену доставки. В это же время другая транзакция добавляет в эту таблицу новый
  кортеж. В итоге цена доставки может быть посчитана неверно.
\end{enumerate}

Блокировки бывают явные (прописываются сразу в тексте транзакции) и неявные
(задан набор правил, по которым блокировка устанавливается автоматически).
Блокировать можно один кортеж, одну таблицу или всю базу данных. Также
блокировки делятся на монопольные (блокируют все виды доступа) и коллективные
(блокируют только внесение изменений).

4 уровня изоляции (каждый уровень решает следующую проблему конкурирующих
транзакций):
\begin{enumerate}
\item
  Незавершенное чтение. Изменять данные должна только одна транзакция.

\item
  Завершенное чтение. Если транзакция собирается менять данные, то она блокирует
  их монопольно.

\item
  Воспроизводимое чтение. Если транзакция планирует читать  данные, то она
  блокирует их монопольно.

\item
  Сериализуемость. Если транзакция обращается к данным, то никакая другая
  транзакция не может добавить новые или изменить существующие строки, которые
  могут быть считаны при выполнении этой транзакции.
\end{enumerate}